\documentclass[a4j]{jarticle}

\usepackage{listings}

\lstset{%
  language={},
  basicstyle={\small\ttfamily},%
  identifierstyle={\small},%
  commentstyle={\small\itshape},%
  keywordstyle={\small\bfseries},%
  ndkeywordstyle={\small},%
  stringstyle={\small\ttfamily},
  frame={tb},
  breaklines=true,
  columns=[l]{fullflexible},%
  numbers=left,%
  xrightmargin=0zw,%
  xleftmargin=3zw,%
  numberstyle={\scriptsize},%
  stepnumber=1,
  numbersep=1zw,%
  lineskip=-0.5ex%
}

\title{システムプログラミング\\期末レポート}
\author{\\学籍番号：09425566\\氏名：佐藤 佑太}
\date{出題日：2014/12/24\\提出日：2014/1/22\\締切り日：2014/1/22\\}

\begin{document}

\maketitle

\newpage



%
%	SECTION 1
%

\section{概要}

このレポートでは，以下に与えられる５つの課題に関しての考察，またそのプログラムを作成する過程を示すものである．ただし，プログラムはMIPSアセンブリ言語で記述し，SPIMを用いて動作を確認する．


\begin{enumerate}

\item SPIMが提供するシステムコールをC言語から実行できるようにしたい。教科書，（以下教科書はコンピュータの構成と設計（パターソン＆ヘネシー）第四版を指すこととする）B.6節．「手続き呼び出し規約」に従って、各種手続きをアセンブラで記述せよ。ファイル名は、syscalls.sとすること。　

また、記述したsyscalls.sの関数をC言語から呼び出すことで、ハノイの塔(hanoi.cとする)を完成させよ。

{\baselineskip 3mm
\begin{verbatim}
void hanoi(int n, int start, int finish, int extra)
{
  if (n!=0) {
    hanoi(n-1, start, extra, finish);
    print_string("Move disk ");
    print_int(n);
    print_string(" from peg ");
    print_int(start);
    print_string(" to peg ");
    print_int(finish);
    print_string(".\n");
    hanoi(n-1, extra, finish, start);
  }
}
main()
{
  int n;
  print_string("Enter number of disks> ");
  n = read_int();
  hanoi(n, 1, 2, 3);
}
\end{verbatim}
}

spim-gccによってhanoi.sができたら、hanoi.s, syscalls.sの順にSPIM上でロードして実行し、その結果を示せ。

\item hanoi.sを例にspim-gccの引数保存に関するスタックの利用方法について、説明書。そのことは、規約上許されるスタックフレームの最小値24とどう関係しているか。このスタックフレームの最小値規約を守らないとどのような問題が生じるかについて解説せよ。


\item 以下のプログラムreport2-1.cをコンパイルした結果をもとに、auto変数とstatic変数の違い、ポインタと配列の違いについてレポートせよ。

{\baselineskip 3mm
\begin{verbatim}
int primes_stat[10];
 
char * string_ptr = "ABCDEFG";
char string_ary[] = "ABCDEFG";
 
void print_var(char *name, int val)
{
  print_string(name);
  print_string(" = ");
  print_int(val);
  print_string("\n");
}
 
main()
{
  int primes_auto[10];
 
  primes_stat[0] = 2;
  primes_auto[0] = 3;
 
  print_var("primes_stat[0]", primes_stat[0]);
  print_var("primes_auto[0]", primes_auto[0]);
}
 
\end{verbatim}
}


\item printfなど、一部の関数は、任意の数の引数を取ることができる。これらの関数を可変引数関数と呼ぶ。MIPSのCコンパイラにおいて可変引数関数の実現方法について考察し、解説せよ。

\item printfのサブセットを実装し、SPIM上でその動作を確認する応用プログラム（自由なでもプログラム）を作成せよ。

\end{enumerate}


%
%	SECTION 2
%

\section{プログラムの作成方針}


\subsection{課題1}

課題1では，与えられたハノイの塔のプログラムhanoi.cに関して、それぞれ

\begin{itemize}
  \item[(1)]print\_string()
  \item[(2)]print\_int()
  \item[(3)]read\_string()
  \item[(4)]read\_int()
\end{itemize}

の4つの関数をアセンブリで定義したsyscalls.sというプログラムを作成し、ハノイの塔のプログラムhanoi.cをクロスコンパイラを用いてMIPS用にコンパイルしたアセンブリプログラムhanoi.sと同時に読み込ませてC言語で書いたプログラムからsyscallを呼び出す、という処理を実現する。

また、出力結果は以下のように表示するようにプログラムを作成する。以下はディスクの枚数を3として実行した結果である。

{\baselineskip 3mm
\begin{verbatim}

Enter number of disks> 3
Move disk 1 from peg 1 to peg 2.
Move disk 2 from peg 1 to peg 3.
Move disk 1 from peg 2 to peg 3.
Move disk 3 from peg 1 to peg 2.
Move disk 1 from peg 3 to peg 1.
Move disk 2 from peg 3 to peg 2.
Move disk 1 from peg 1 to peg 2.
 
\end{verbatim}
}



\subsection{課題5}

課題5では，以下の２つの関数とひとつのアセンブリプログラムを作成する．処理の概要は以下の通りに定め，下記でそれぞれについて解説する

\begin{itemize}
\item[(1)]フォーマットに従い適切な出力をコンソールに表示する関数myprintf()
\item[(2)]任意のフォーマットを引数にmyprintf()関数を呼び出すmain関数
\item[(3)]適切な値をコンソールに出力する関数を定義したアセンブリプログラムsyscalls.s
\end{itemize}


(1)myprintf()関数では，与えられた引数に関して適切な形で変数の代入などを行いコンソール上に結果を出力する。
(2)main関数では，myprintf() 関数を、任意の引数とともに呼び出す。
(3)syscalls.sではmyprintf()関数内である変数の内容を表示する場合にそれぞれ適切な型でコンソールに出力する関数を複数定義するプログラム。



%
%	SECTION 3
%

\section{プログラムリストおよび、その説明}

それぞれの課題について，完成したプログラムを末尾に添付する．このセクションでは，プログラムの主な構造について説明する．

\subsection{課題1}

まず，SPIMでコンソール上に出力を表示する方法を記述する。

SPIMでオペレーティングシステム的なサービスを実行するためには，システムコール(syscall)という命令を使うことになっている．

syscallを使い，サービスを要求する手順は以下のようにまとめることができる．

\begin{itemize}
\item[1]1. レジスタ\$v0に使いたいサービスのシステムコールコードを格納
\item[2]2. 引数をレジスタ\$a0から\$a3（浮動小数点数の値は\$f12）にロード
\item[3]3. 値を返すシステムコールは結果をレジスタ\$v0（浮動小数点数の値の場合は\$f0）に収める
\item[4]4. syscallで実行
\end{itemize}

サービスを使うためには手順１で\$v0に使いたいサービスの対応するデータをintで渡さなければならない．これをシステムコールコードという．(参考文献1 P.781参照)


次に，作成したプログラムsyscalls.sの説明をする．

まずprint\_int関数から解説を行う。


関数が呼ばれた直後に、被呼び出し側でスタックフレームの領域を確保し、\$spを退避する。ここでは24バイト分確保している。

% TODO: Resource of this information
また、C言語から関数を呼び出すときには\_funcname:のように最初にアンダーバーをつけること。これはコンパイルに依存し、今回はgccを用いている。　

{\baselineskip 3mm
\begin{verbatim}

\_print\_int:
  subu  $sp, $sp, 24
  sw    $ra, 20($sp)
 
\end{verbatim}
}

次の2行で、各サービスに対応するシステムコールコードを\$v0に格納してsyscallを実行している。ここでは、引数は\$a0に格納されて渡されることを仕様の前提としており、それを利用している。

{\baselineskip 3mm
\begin{verbatim}

li    $v0, 1  # 1: print_int
syscall
 
\end{verbatim}
}

次の3行で、戻りアドレスを復元し、スタックフレームを破棄、復元した戻りアドレスに従ってもとの場所にジャンプ、という処理を行っている。

{\baselineskip 3mm
  \begin{verbatim}

lw    $ra, 20($sp)
addu  $sp, $sp, 24
j     $ra


  \end{verbatim}
}

他の4つの関数print\_int, read\_string, read\_intについても同様の処理を行う。各関数の定義で異なっているのはシステムコールコードの値のみである。



\subsection{課題5}

末尾に添付したプログラムmyprintf.cについて解説を行う。

main()関数では、任意のフォーマットと引数とともにmyprintf()関数を呼び出す処理を行う

{\baselineskip 3mm
  \begin{verbatim}

int main() {
  myprintf("I am %s, my age is %d", "Yuta Totsuka", 21);
  return 0;
}

\end{verbatim}
}

プログラムが実行されると、まずこのmain関数が呼ばれ、myprintf()関数を呼び出す。このサンプルでは可変引数として

\begin{itemize}
\item[1]"I am \%s, my age is \%d": string
\item[2]"Yuta Totsuka": string
\item[3]21: integer
\end{itemize}

の3つの引数を与えることとする。

このmyprintf()関数が無事実行されたらmain()関数は0を返してこのプログラムは終了する。


次に、myprintf()関数部について説明する。

まず、この関数では可変引数を受け取る必要がある。1つめはfmtをchar型のポインタで、2つ目以降は...の形で受け取っている。

\begin{verbatim}
void myprintf(char *fmt, ...) {
\end{verbatim}

以下で必要な引数を宣言している。

{\baselineskip 3mm
  \begin{verbatim}

int i, argc = 0;
char *s;

\end{verbatim}
}

一番外側のループであるwhileでは、fmt++で*fmtのポインタが指す場所をひとつずつ繰り上げていき、char *fmtの中身がなくなるまで出力する処理を繰り返す、という仕組みである。

{\baselineskip 3mm
  \begin{verbatim}

while (*fmt) {

// 出力処理

    fmt++;
}

\end{verbatim}
}

続いて上記出力処理部分では*fmtが指すデータが'\%'だった場合とそうでない場合とで出力の処理を分岐する。

{\baselineskip 3mm
  \begin{verbatim}

// 出力処理
 if (*fmt == '%') {
      // 各型に対応する変数の出力処理
    }else {
      // 文字をそのまま出力
    }
    fmt++;

\end{verbatim}
}

'\%'だった場合はその'\%'自体は出力せずにfmtを繰り上げ次のアドレスを指すようにし、そこに入っているアルファベットに従って、switchで各型に応じた出力処理に振り分ける、という処理を行う。

{\baselineskip 3mm
  \begin{verbatim}

 // 各型に対応する変数の出力処理
      fmt++;
      argc++;
      switch (*fmt) {
        case '%':
          // Process of %%
          break;
        case 'c':
          // Process of %c
          break;
        case 'd':
          // Process of %d
          i = *((int*) ((char *)&fmt + argc * sizeof(void *)) );
          print_int(i);
          break;
        case 'u':
          // Process of %u
          break;
        case 's':
          // Process of %s
          s = *((int*) ((char *)&fmt + argc * sizeof(void *)) );
          print_string(s);
          break;
        break;
      }

\end{verbatim}
}

'\%'以外の場合はその文字をそのまま出力する。

{\baselineskip 3mm
  \begin{verbatim}

      // 文字をそのまま出力 
      print_char(*fmt);

\end{verbatim}
}


また、stdio.hライブラリで実装されているprintf()関数を使わずにmyprintf()関数を実現するために、コンソールに文字を出力するための関数をsyscalls.sで定義している。各関数で行っている処理の詳細は、section3.1を参照。 




%
%	SECTION 4
%

\section{プログラムの使用例・テスト}

このセクションでは，プログラムの使用例を示しながら実際にテストを行う過程を示す．

\subsection{課題1}

hanoi.cをクロスコンパイラを用いてMIPSプラットフォーム向けのアセンブリプログラムhanoi.sを作成する。　

その後spimを用いてhanoi.s、syscalls.sという順番でプログラムをロードして実行すると、以下のように表示されハノイの塔の高さをきかれる。　

{\baselineskip 3mm
\begin{verbatim}
Enter number of disks > 
\end{verbatim}
}

ここで3を入力すると、ハノイの塔の手順が以下のようにコンソールに出力される。　

{\baselineskip 3mm
\begin{verbatim}

Enter number of disks> 3
Move disk 1 from peg 1 to peg 2.
Move disk 2 from peg 1 to peg 3.
Move disk 1 from peg 2 to peg 3.
Move disk 3 from peg 1 to peg 2.
Move disk 1 from peg 3 to peg 1.
Move disk 2 from peg 3 to peg 2.
Move disk 1 from peg 1 to peg 2.
 
\end{verbatim}
}





\subsection{課題5}

プログラムを実行すると，10の階乗の値をコンソール上に以下のように表示する．

クロスコンパイラを用いてmyprintf.cをmyprintf.sにコンパイラする。　

myprintf.s、syscalls.sの順にプログラムをspimでロードし実行すると以下のような出力を得ることができる。

{\baselineskip 3mm
\begin{verbatim}
I am Yuta Totsuka, my age is 21
\end{verbatim}
}


% HERE



%
%	SECTION 5
%

\section{プログラム作成における考察}

各課題において，プログラム作成過程における考察を以下に示す．

\subsection{課題1}


\subsection{課題5}


s = *((int*) ((char *)\&fmt + argc * sizeof(void *)) ); ここの部分どうなってんねん！

なぜCプログラム中でprint\_charを作ったのか？アセンブリのsyscallのサービスとして提供されていなかっただろうか。（番号11）




%
%	SECTION 6
%

\section{得られた結果に関する，あるいは試問に対する回答}


各課題において，得られた結果に関する，あるいは試問に対する回答を以下に示す．
また，結果に対してわいたいくつかの疑問点とそれについての考察を記述する．


\subsection{課題1}
\subsection{課題2}
\subsection{課題3}

report2-1.cをMIPSプラットフォーム向けにコンパイルしたプログラムreport2-1.sを読むことで、C言語におけるauto変数とstatic変数を、アセンブリでどのように実現しているのかを理解する。

mips-gccでコンパイルしたreport2-1.sは以下のようになった。

\begin{verbatim}


	.file	1 "report2-1.c"
 
 # -G value = 0, Cpu = r2000, ISA = 1
 # GNU C version 2.96-mips3264-000710 (mipsel-linux) compiled by GNU C version 2.96 20000731 (Red Hat Linux 7.2 2.96-112.7.2).
 # [AL 1.1, MM 40] BSD Mips
 # options passed:  -mno-abicalls -mrnames -mmips-as
 # -mno-check-zero-division -mcpu=r2000 -O0 -fleading-underscore
 # -finhibit-size-directive -fverbose-asm
 # options enabled:  -fpeephole -fkeep-static-consts -fpcc-struct-return
 # -fsched-interblock -fsched-spec -fnew-exceptions -fcommon
 # -finhibit-size-directive -fverbose-asm -fgnu-linker -flive-range-gdb
 # -fargument-alias -fleading-underscore -fdelay-postincrement -fident
 # -fmath-errno -msplit-addresses -mrnames -mno-check-zero-division
 # -mdebugf -mdebugi -mno-div-checks -mcpu=r2000
 
 
	.rdata
	.align	0
	.align	2
$LC0:
	.asciiz	"ABCDEFG"
	.data
	.align	0
	.align	2
_string_ptr:
	.word	$LC0
	.align	2
_string_ary:
	.asciiz	"ABCDEFG"
	.rdata
	.align	0
	.align	2
$LC1:
	.asciiz	" = "
	.align	2
$LC2:
	.asciiz	"\n"
	.text
	.align	2
	.set	nomips16
_print_var:
	subu	$sp,$sp,24
	sw	$ra,20($sp)
	sw	$fp,16($sp)
	move	$fp,$sp
	sw	$a0,24($fp)
	sw	$a1,28($fp)
	lw	$a0,24($fp)
	jal	_print_string
	la	$a0,$LC1
	jal	_print_string
	lw	$a0,28($fp)
	jal	_print_int
	la	$a0,$LC2
	jal	_print_string
	move	$sp,$fp
	lw	$ra,20($sp)
	lw	$fp,16($sp)
	addu	$sp,$sp,24
	j	$ra
	.rdata
	.align	0
	.align	2
$LC3:
	.asciiz	"primes_stat[0]"
	.align	2
$LC4:
	.asciiz	"primes_auto[0]"
	.text
	.align	2
	.set	nomips16
main:
	subu	$sp,$sp,64
	sw	$ra,60($sp)
	sw	$fp,56($sp)
	move	$fp,$sp
	li	$v0,2			# 0x2
	sw	$v0,_primes_stat
	li	$v0,3			# 0x3
	sw	$v0,16($fp)
	la	$a0,$LC3
	lw	$a1,_primes_stat
	jal	_print_var
	la	$a0,$LC4
	lw	$a1,16($fp)
	jal	_print_var
	move	$sp,$fp
	lw	$ra,60($sp)
	lw	$fp,56($sp)
	addu	$sp,$sp,64
	j	$ra
 
	.comm	_primes_stat,40
 

\end{verbatim}

まずstaticについての説明を行う。

report2-1.sプログラムの最後に以下のような記述がある。

\begin{verbatim}
 .comm   _primes_stat,40
\end{verbatim}

これは以下と同じ命令である。

\begin{verbatim}
 .data
    .align 2
    _primes_start:
        .space  40
\end{verbatim}

ここでは、データセグメント内に、\_primes\_startというラベルをつけて、データを40バイト確保している。

つまりこのときに長さ10の配列のために確保された40バイトは、この配列を使うためだけに確保されている。よってこれは、プログラムの開始から終了時まで、値を保持しつづけるという性質を持つことになる。

だがあくまでこれは規約上であり絶対に上書きされないということはない。関数などが再帰的に呼び出された場合は、その領域を上書きすることがある。

その領域しか使わないからこそ、再帰的な処理の時などのときの処理は煩雑になりそうである。


次にmain部分にフォーカスして読んでいく。

まず64バイト分のスタックフレームを生成し、戻りアドレス\$raとフレームポインタ\$fpを更新。

\begin{verbatim}
main:
    subu    $sp,$sp,64
    sw  $ra,60($sp)
    sw  $fp,56($sp)
\end{verbatim}

その後フレームポインタを\$spと同じアドレスを指すようにする。

上で一度\$fpを更新してもう一度ここで更新する意味が理解できないが、それは後の疑問点で考察する。

\begin{verbatim}
 move    $fp,$sp
\end{verbatim}

次に各配列の先頭の値を準備する。

まずはstatic変数側の配列の先頭の値を準備する。

ここでは、\$v0の値を\_primes\_startラベルで確保されてるデータセグメントの最初に格納していることに注意。


\begin{verbatim}
 li  $v0,2           # 0x2
    sw  $v0,_primes_stat
\end{verbatim}

次はauto変数に対応する部分についてみていく。16(\$fp)ということで、スタックフレームのデータ4個分のところに値を格納している。

なぜ16なのかは、疑問点にて考察する。

\begin{verbatim}
 li  $v0,3           # 0x3
    sw  $v0,16($fp)
\end{verbatim}

出力する予定の文字列を読み込んで、さっき格納したstaticの配列の一番最初の値を持ってきて、出力するためのルーチンを呼ぶ。

\begin{verbatim}
 la  $a0,$LC3
    lw  $a1,_primes_stat
    jal _print_var
\end{verbatim}

今度はautoでも同じことをする。

\begin{verbatim}
 la  $a0,$LC4
    lw  $a1,16($fp)
    jal _print_var
\end{verbatim}

スタックを解放してmain部終了。

\begin{verbatim}
 move    $sp,$fp
    lw  $ra,60($sp)
    lw  $fp,56($sp)
    addu    $sp,$sp,64
    j   $ra
\end{verbatim}

ここからわかるように、auto変数では、static変数と違って スタックで配列を管理していることが分かる。

つまり、この関数が終了すれば\$spに確保したバイト数が足され、スタックが解放され、その結果保持していたauto変数の配列も消えてしまう。

ここから、アセンブリ言語では、C言語のstatic変数をメモリに別の領域として確保して扱い、auto変数をプログラム中の関数のスタックに格納することによって、両者の性質を実現していることが分かる。


\subsection{課題4}
\subsection{課題5}



\newpage

%
%	SECTION 6
%

\section{作成したプログラムのソースコード}

それぞれについて，作成したプログラムは以下である．

\subsection{課題1}

% \lstinputlisting[caption=putc.s, label=putc.s]{./source/putc.s}

% \lstinputlisting[caption=putc2.s, label=putc2.s]{./source/putc2.s}


\subsection{課題5}

%  \lstinputlisting[caption=prime2.s, label=prime2.s]{./source/prime2.s}


%
% SECTION 7
%

\section{参考文献}

\begin{enumerate}
\item コンピュータの構成と設計 第4版 上・下 ジョン・L. ヘネシー (著), デイビッド・A. パターソン (著), 成田 光彰 (翻訳)
\item Computer Organization and Design, Fifth Edition: The Hardware/Software Interface (The Morgan Kaufmann Series in Computer Architecture and Design) by David A. Patterson (Author), John L. Hennessy  (Author)
\end{enumerate}


\end{document}

