\documentclass[a4j]{jarticle}

\usepackage{listings}

\lstset{%
  language={},
  basicstyle={\small\ttfamily},%
  identifierstyle={\small},%
  commentstyle={\small\itshape},%
  keywordstyle={\small\bfseries},%
  ndkeywordstyle={\small},%
  stringstyle={\small\ttfamily},
  frame={tb},
  breaklines=true,
  columns=[l]{fullflexible},%
  numbers=left,%
  xrightmargin=0zw,%
  xleftmargin=3zw,%
  numberstyle={\scriptsize},%
  stepnumber=1,
  numbersep=1zw,%
  lineskip=-0.5ex%
}

\title{システムプログラミング\\期末レポート}
\author{\\学籍番号：09425566\\氏名：佐藤 佑太}
\date{出題日：2014/12/24\\提出日：2014/1/22\\締切り日：2014/1/22\\}

\begin{document}

\maketitle

\newpage



%
%	SECTION 1
%

\section{概要}

このレポートでは，以下に与えられる５つの課題に関しての考察，またそのプログラムを作成する過程を示すものである．ただし，プログラムはMIPSアセンブリ言語で記述し，SPIMを用いて動作を確認する．


\begin{enumerate}

\item SPIMが提供するシステムコールをC言語から実行できるようにしたい。教科書，（以下教科書はコンピュータの構成と設計（パターソン＆ヘネシー）第四版を指すこととする）B.6節．「手続き呼び出し規約」に従って、各種手続きをアセンブラで記述せよ。ファイル名は、syscalls.sとすること。　

また、記述したsyscalls.sの関数をC言語から呼び出すことで、ハノイの塔(hanoi.cとする)を完成させよ。

{\baselineskip 3mm
\begin{verbatim}
void hanoi(int n, int start, int finish, int extra)
{
  if (n!=0) {
    hanoi(n-1, start, extra, finish);
    print_string("Move disk ");
    print_int(n);
    print_string(" from peg ");
    print_int(start);
    print_string(" to peg ");
    print_int(finish);
    print_string(".\n");
    hanoi(n-1, extra, finish, start);
  }
}
main()
{
  int n;
  print_string("Enter number of disks> ");
  n = read_int();
  hanoi(n, 1, 2, 3);
}
\end{verbatim}
}

spim-gccによってhanoi.sができたら、hanoi.s, syscalls.sの順にSPIM上でロードして実行し、その結果を示せ。

\item hanoi.sを例にspim-gccの引数保存に関するスタックの利用方法について、説明書。そのことは、規約上許されるスタックフレームの最小値24とどう関係しているか。このスタックフレームの最小値規約を守らないとどのような問題が生じるかについて解説せよ。


\item 以下のプログラムreport2-1.cをコンパイルした結果をもとに、auto変数とstatic変数の違い、ポインタと配列の違いについてレポートせよ。

{\baselineskip 3mm
\begin{verbatim}
int primes_stat[10];
 
char * string_ptr = "ABCDEFG";
char string_ary[] = "ABCDEFG";
 
void print_var(char *name, int val)
{
  print_string(name);
  print_string(" = ");
  print_int(val);
  print_string("\n");
}
 
main()
{
  int primes_auto[10];
 
  primes_stat[0] = 2;
  primes_auto[0] = 3;
 
  print_var("primes_stat[0]", primes_stat[0]);
  print_var("primes_auto[0]", primes_auto[0]);
}
 
\end{verbatim}
}


\item printfなど、一部の関数は、任意の数の引数を取ることができる。これらの関数を可変引数関数と呼ぶ。MIPSのCコンパイラにおいて可変引数関数の実現方法について考察し、解説せよ。

\item printfのサブセットを実装し、SPIM上でその動作を確認する応用プログラム（自由なでもプログラム）を作成せよ。

\end{enumerate}


%
%	SECTION 2
%

\section{プログラムの作成方針}


\subsection{課題1}

課題1では，与えられたハノイの塔のプログラムhanoi.cに関して、それぞれ

\begin{itemize}
  \item[(1)]print\_string()
  \item[(2)]print\_int()
  \item[(3)]read\_string()
  \item[(4)]read\_int()
\end{itemize}

の4つの関数をアセンブリで定義したsyscalls.sというプログラムを作成し、ハノイの塔のプログラムhanoi.cをクロスコンパイラを用いてMIPS用にコンパイルしたアセンブリプログラムhanoi.sと同時に読み込ませてC言語で書いたプログラムからsyscallを呼び出す、という処理を実現する。

また、出力結果は以下のように表示するようにプログラムを作成する。以下はディスクの枚数を3として実行した結果である。

{\baselineskip 3mm
\begin{verbatim}

Enter number of disks> 3
Move disk 1 from peg 1 to peg 2.
Move disk 2 from peg 1 to peg 3.
Move disk 1 from peg 2 to peg 3.
Move disk 3 from peg 1 to peg 2.
Move disk 1 from peg 3 to peg 1.
Move disk 2 from peg 3 to peg 2.
Move disk 1 from peg 1 to peg 2.
 
\end{verbatim}
}



\subsection{課題5}

課題5では，以下の２つの関数とひとつのアセンブリプログラムを作成する．処理の概要は以下の通りに定め，下記でそれぞれについて解説する

\begin{itemize}
\item[(1)]フォーマットに従い適切な出力をコンソールに表示する関数myprintf()
\item[(2)]任意のフォーマットを引数にmyprintf()関数を呼び出すmain関数
\item[(3)]適切な値をコンソールに出力する関数を定義したアセンブリプログラムsyscalls.s
\end{itemize}


(1)myprintf()関数では，与えられた引数に関して適切な形で変数の代入などを行いコンソール上に結果を出力する。
(2)main関数では，myprintf() 関数を、任意の引数とともに呼び出す。
(3)syscalls.sではmyprintf()関数内である変数の内容を表示する場合にそれぞれ適切な型でコンソールに出力する関数を複数定義するプログラム。



%
%	SECTION 3
%

\section{プログラムリストおよび、その説明}

それぞれの課題について，完成したプログラムを末尾に添付する．このセクションでは，プログラムの主な構造について説明する．

\subsection{課題1}

まず，SPIMでコンソール上に出力を表示する方法を記述する。

SPIMでオペレーティングシステム的なサービスを実行するためには，システムコール(syscall)という命令を使うことになっている．

syscallを使い，サービスを要求する手順は以下のようにまとめることができる．

\begin{itemize}
\item[1]1. レジスタ\$v0に使いたいサービスのシステムコールコードを格納
\item[2]2. 引数をレジスタ\$a0から\$a3（浮動小数点数の値は\$f12）にロード
\item[3]3. 値を返すシステムコールは結果をレジスタ\$v0（浮動小数点数の値の場合は\$f0）に収める
\item[4]4. syscallで実行
\end{itemize}

サービスを使うためには手順１で\$v0に使いたいサービスの対応するデータをintで渡さなければならない．これをシステムコールコードという．(参考文献1 P.781参照)


次に，作成したプログラムsyscalls.sの説明をする．

まずprint\_int関数から解説を行う。


関数が呼ばれた直後に、被呼び出し側でスタックフレームの領域を確保し、\$spを退避する。ここでは24バイト分確保している。

% TODO: Resource of this information
また、C言語から関数を呼び出すときには\_funcname:のように最初にアンダーバーをつけること。これはコンパイルに依存し、今回はgccを用いている。　

{\baselineskip 3mm
\begin{verbatim}

\_print\_int:
  subu  $sp, $sp, 24
  sw    $ra, 20($sp)
 
\end{verbatim}
}

次の2行で、各サービスに対応するシステムコールコードを\$v0に格納してsyscallを実行している。ここでは、引数は\$a0に格納されて渡されることを仕様の前提としており、それを利用している。

{\baselineskip 3mm
\begin{verbatim}

li    $v0, 1  # 1: print_int
syscall
 
\end{verbatim}
}

次の3行で、戻りアドレスを復元し、スタックフレームを破棄、復元した戻りアドレスに従ってもとの場所にジャンプ、という処理を行っている。

{\baselineskip 3mm
  \begin{verbatim}

lw    $ra, 20($sp)
addu  $sp, $sp, 24
j     $ra


  \end{verbatim}
}

他の4つの関数print\_int, read\_string, read\_intについても同様の処理を行う。各関数の定義で異なっているのはシステムコールコードの値のみである。



\subsection{課題5}

末尾に添付したプログラムmyprintf.cについて解説を行う。

main()関数では、任意のフォーマットと引数とともにmyprintf()関数を呼び出す処理を行う

{\baselineskip 3mm
  \begin{verbatim}

int main() {
  myprintf("I am %s, my age is %d", "Yuta Totsuka", 21);
  return 0;
}

\end{verbatim}
}

プログラムが実行されると、まずこのmain関数が呼ばれ、myprintf()関数を呼び出す。このサンプルでは可変引数として

\begin{itemize}
\item[1]"I am %s, my age is %d": string
\item[2]"Yuta Totsuka": string
\item[3]21: integer
\end{itemize}

の3つの引数を与えることとする。

このmyprintf()関数が無事実行されたらmain()関数は0を返してこのプログラムは終了する。


次に、myprintf()関数部について説明する。

まず、この関数では可変引数を受け取る必要がある。1つめはfmtをchar型のポインタで、2つ目以降は...の形で受け取っている。

\begin{verbatim}
void myprintf(char *fmt, ...) {
\end{verbatim}

以下で必要な引数を宣言している。

{\baselineskip 3mm
  \begin{verbatim}

int i, argc = 0;
char *s;

\end{verbatim}
}

一番外側のループであるwhileでは、fmt++で*fmtのポインタが指す場所をひとつずつ繰り上げていき、char *fmtの中身がなくなるまで出力する処理を繰り返す、という仕組みである。

{\baselineskip 3mm
  \begin{verbatim}

while (*fmt) {

// 出力処理

    fmt++;
}

\end{verbatim}
}

続いて上記出力処理部分では*fmtが指すデータが'\%'だった場合とそうでない場合とで出力の処理を分岐する。

{\baselineskip 3mm
  \begin{verbatim}

// 出力処理
 if (*fmt == '%') {
      // 各型に対応する変数の出力処理
    }else {
      // 文字をそのまま出力
    }
    fmt++;

\end{verbatim}
}

'\%'だった場合はその'\%'自体は出力せずにfmtを繰り上げ次のアドレスを指すようにし、そこに入っているアルファベットに従って、switchで各型に応じた出力処理に振り分ける、という処理を行う。

{\baselineskip 3mm
  \begin{verbatim}

 // 各型に対応する変数の出力処理
      fmt++;
      argc++;
      switch (*fmt) {
        case '%':
          // Process of %%
          break;
        case 'c':
          // Process of %c
          break;
        case 'd':
          // Process of %d
          i = *((int*) ((char *)&fmt + argc * sizeof(void *)) );
          print_int(i);
          break;
        case 'u':
          // Process of %u
          break;
        case 's':
          // Process of %s
          s = *((int*) ((char *)&fmt + argc * sizeof(void *)) );
          print_string(s);
          break;
        break;
      }

\end{verbatim}
}

'\%'以外の場合はその文字をそのまま出力する。

{\baselineskip 3mm
  \begin{verbatim}

      // 文字をそのまま出力 
      print_char(*fmt);

\end{verbatim}
}


また、stdio.hライブラリで実装されているprintf()関数を使わずにmyprintf()関数を実現するために、コンソールに文字を出力するための関数をsyscalls.sで定義している。各関数で行っている処理の詳細は、section3.1を参照。 




%
%	SECTION 4
%

\section{プログラムの使用例・テスト}

このセクションでは，プログラムの使用例を示しながら実際にテストを行う過程を示す．

\subsection{課題1}

hanoi.cをクロスコンパイラを用いてMIPSプラットフォーム向けのアセンブリプログラムhanoi.sを作成する。　

その後spimを用いてhanoi.s、syscalls.sという順番でプログラムをロードして実行すると、以下のように表示されハノイの塔の高さをきかれる。　

{\baselineskip 3mm
\begin{verbatim}
Enter number of disks > 
\end{verbatim}
}

ここで3を入力すると、ハノイの塔の手順が以下のようにコンソールに出力される。　

{\baselineskip 3mm
\begin{verbatim}

Enter number of disks> 3
Move disk 1 from peg 1 to peg 2.
Move disk 2 from peg 1 to peg 3.
Move disk 1 from peg 2 to peg 3.
Move disk 3 from peg 1 to peg 2.
Move disk 1 from peg 3 to peg 1.
Move disk 2 from peg 3 to peg 2.
Move disk 1 from peg 1 to peg 2.
 
\end{verbatim}
}





\subsection{課題5}

プログラムを実行すると，10の階乗の値をコンソール上に以下のように表示する．

クロスコンパイラを用いてmyprintf.cをmyprintf.sにコンパイラする。　

myprintf.s、syscalls.sの順にプログラムをspimでロードし実行すると以下のような出力を得ることができる。

{\baselineskip 3mm
\begin{verbatim}
I am Yuta Totsuka, my age is 21
\end{verbatim}
}


% HERE



%
%	SECTION 5
%

\section{プログラム作成における考察}

各課題において，プログラム作成過程における考察を以下に示す．

\subsection{課題1}

プログラムを作成している過程で，以下のエラーが出た．

\begin{quote}
Instruction references undefined symbol at 0x00400014
\end{quote}

ステップ実行で確認してみたところ，jal命令においてmainがないというメッセージが出ていたのでmainを追加したところ，さらに次のようなエラーが出力された．

\begin{quote}
Attempt to execute non-instruction at 0x0040003c
\end{quote}

抜け出す処理が必要だと推定し，jr命令でmainから戻る設定を行うようにプログラムを書き直すと，正常に動作するようになった．

以上のことから，main部分はプログラム開始時に，プログラムの内容に関わらず一番最初に呼ばれる処理が実行されていることがわかる．またこのことから，main部分に関しても呼び出し側に戻る必要があることもわかる．

また，jal命令には，実行されると同時に\$raに自動で戻りアドレスを格納する機能があるということも推測できる．

MIPSアセンブリ言語において，戻りアドレスを保持することは非常に重要なことであり，これをプログラマーが任意で値を書き換えないように注意しなければならないだろう．




\subsection{課題3}

\subsubsection{疑問点1}

なぜスタックフレームを生成するには\$spから値を「引く」のか？

\begin{quote}
スタックポインタからフレームのサイズを引いて、フレーム用にメモリを割り当てる 

(参考文献1 p. 764)
\end{quote}

スタックフレームは低位から高位のメモリアドレスにフレームを生成することを考えればわかりやすい．\$fpは最初初期値が\$spと同じように設定されていて、\$spから引いた数の分だけ\$spと\$fpの差は開き、そこがフーレムとして生成されることを考えればよい．

これより，\$spから欲しいバイト分だけ値を引けば，その分下に伸びるイメージで確保領域が広くなっている．そして，\$fpはスタックからのデータ取得を簡易化するためのものなので，この原理を知り，4バイトずつ計算することができれば\$spのみでスタックを利用することもできる．

\subsubsection{疑問点2}

なぜスタックフレームの大きさは24バイト以上で，8バイト単位なのか？  

\begin{quote}
この最低限のフレームに４つの引数レジスタ (\$a0 - \$a3) と戻りアドレス\$raを、倍長語の境界に整列化して持たせることができる。mainでは\$fpも退避する必要があるので、スタックフレームを2語分大きくしなければならない。（スタックフレームは倍長語の境界に整列化されることに留意）(参考文献１P.766)

The frame is larger than required for these two register because the calling convention requires the minimum size of a stack frame to be 24 bytes. This minimum frame can hold four argument registers (\$a0-\$a3) and the return address \$ra, padded to a double-word boundary (24 bytes). Since main also needs to save \$fp, its stack frame must be two words larger (remember: the stack pointer is kept doubleword aligned).（参考文献２）
\end{quote}

\$raと\$fa，またコンパイルする際に最低限ひつようであるから，スタックフレームは最低限24バイト必要である．

よって，さらにデータを確保したい場合は，32バイト，40バイトとスタックフレームのサイズを大きくする必要がある．

これはMIPSが32ビットコンピュータとして作動していることに由来している．

整列化，つまり倍長語の8バイトずつデータを区切るのは32ビットコンピュータがデータの区切りを明確に理解しながらデータを読み込むことでより効率的に処理できるからである．




\subsection{課題4}

prime(n)関数では，今回はチェックしたい値に対して全ての数で割り，その余りを算出することで素数であるかどうかを判定したが，その部分のアルゴリズムはもっと簡略に書けるだろう．今回は時間を確保できなかったので，次の課題として挑戦したい．


\subsection{課題5}

s = *((int*) ((char *)&fmt + argc * sizeof(void *)) ); ここの部分どうなってんねん！

なぜCプログラム中でprint_charを作ったのか？アセンブリのsyscallのサービスとして提供されていなかっただろうか。（番号11）




%
%	SECTION 6
%

\section{得られた結果に関する，あるいは試問に対する回答}


各課題において，得られた結果に関する，あるいは試問に対する回答を以下に示す．
また，結果に対してわいたいくつかの疑問点とそれについての考察を記述する．


\subsection{課題2}

ピリオドで始まるシンボル名はアセンブラ指令と呼ばれ，これはプログラムを翻訳する方法をアセンブラに指示するものである．つまり，CPUが直接実行するわけではないが，プログラム実行に不可欠なデータの用意や，メモリ中におけるプログラムの配置をコントロールするこことがアセンブラ指令の目的である．

それぞれに意味があり，簡略にまとめると以下のようになる．

\begin{center}
\begin{tabular}{lclcl}\hline
シンボル&意味\\ \hline \hline
.text&後続行に命令が含まれることを示す\\ \hline
.data&後続の行にデータが含まれることを示す\\ \hline
.align n&後続行中の項目を2のn乗バイトの境界に合わせて整列化しなければならい\\ \hline
.global main&mainをグローバルな記号として宣言\\ \hline
.asciiz&メモリ中に格納する文字列の末尾にnullを付加することを示す\\ \hline
\end{tabular}
\end{center}

特に，.dataと.text，また.align nについて詳しく考察してみることにする．

まず，.dataと.textは，メモリのどこにデータやテキストを格納するかを制御するためのものである．

テキストデータはASCII tableに従った数字として最終的に保存されるため，テキストとしてのデータなのかそれ以外のデータなのか，コンピュータは判断することができない．そこで，アセンブラ指令を用いてもともとテキストとデータを保存する場所を区別するために.dataと.textを使い分ける必要があるのだろう．

そのため，.dataがない場合，コンピュータはtext型のデータと勘違いしてしまい適切なデーtあセグメントにデータを配置できず，予期せぬ出力を行う可能性が有ると考えられる．

次に，.align nというアセンブラ指令について考察してみる．

MIPSは32ビットアーキテクチャである．それはつまり，4バイト分ずつデータを読み込んでいく，ということだ．このため，CPUが効率的に動くためには，4バイト分ずつきちんとデータが区切れている必要がある．

データのサイズに合わせて，手動で間を埋めて整列させることもできるが，データの量が多くなると厳しい．そこで，それらの整列化を自動でやってくれるのが.align nというアセンブラ指令である．


\subsection{課題3}

手続き呼び出し規約におけるスタックフレームの生成に関して，

\begin{quote}
Register $fp is saved by every procedure that allocates a new stac frame. However, register $ra only needs to be saved if the callee itself makes a call.

(参考文献2)
\end{quote}

という記述に気をつけたい．\$fpは被呼び出し側がさらに呼び出し側にならないケースでも必ず退避させなければならない．

また，7行目でaddiu命令で\$fpに格納しているのが\$sp+28であるという部分．ここでは32バイト分のスタックフレームを生成しているが，フレームポインタの指し示す部分はそのマイナス４バイトである28となることでスタックの先頭，一つ目を\$fpが指すようにフレームポインタを設定できる．  


疑問点1: 関数が返せる引数はひとつまでなのか

スタックを使えば複数の値を擬似的に返すことはできるかもしれないが，規約には反しているかもしれない．

疑問点2:  なぜ\$fpは必ず退避させなければならないのか

呼び出し側がさらに呼び出し側になる場合\$raが退避させる必要はあるのは納得できるが，それ以外の時は退避する必要がないように思える．

これに関しては「後半で\$fpを存分に使うのでそこで学べる」とうい回答をいただいた．

疑問点3: mainからfactを呼ぶとき\$a0は退避しないでよいのか

\$a0-\$a3は退避する必要がないのか．


\newpage

%
%	SECTION 6
%

\section{作成したプログラムのソースコード}

それぞれについて，作成したプログラムは以下である．

\subsection{課題1}

\lstinputlisting[caption=putc.s, label=putc.s]{./source/putc.s}

\lstinputlisting[caption=putc2.s, label=putc2.s]{./source/putc2.s}

\subsection{課題3}

\lstinputlisting[caption=factorial.s, label=factorial.s]{./source/factorial.s}

\subsection{課題4}

\lstinputlisting[caption=prime.s, label=prime.s]{./source/prime.s}

\subsection{課題5}

\lstinputlisting[caption=prime2.s, label=prime2.s]{./source/prime2.s}


%
% SECTION 7
%

\section{参考文献}

\begin{enumerate}
\item コンピュータの構成と設計 第4版 上・下 ジョン・L. ヘネシー (著), デイビッド・A. パターソン (著), 成田 光彰 (翻訳)
\item Computer Organization and Design, Fifth Edition: The Hardware/Software Interface (The Morgan Kaufmann Series in Computer Architecture and Design) by David A. Patterson (Author), John L. Hennessy  (Author)
\end{enumerate}


\end{document}

