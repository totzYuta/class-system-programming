\documentclass[a4j]{jarticle}

\usepackage{listings}

\lstset{%
  language={C},
  basicstyle={\small},%
  identifierstyle={\small},%
  commentstyle={\small\itshape},%
  keywordstyle={\small\bfseries},%
  ndkeywordstyle={\small},%
  stringstyle={\small\ttfamily},
  frame={tb},
  breaklines=true,
  columns=[l]{fullflexible},%
  numbers=left,%
  xrightmargin=0zw,%
  xleftmargin=3zw,%
  numberstyle={\scriptsize},%
  stepnumber=1,
  numbersep=1zw,%
  lineskip=-0.5ex%
}

\title{システムプログラミング\\中間レポート}
\author{\\学籍番号：09425566\\氏名：戸塚(佐藤)佑太}
\date{出題日：2014/11/20\\提出日：2014/11/27\\締切り日：2014/11/27\\}

\begin{document}
\maketitle

\newpage



%
%	SECTION 1
%

\section{概要}

このレポートでは，以下に与えられる５つの課題に関しての考察，またそのプログラムを作成する過程を示すものである．ただし，プログラムはMIPSアセンブリ言語で記述し，SPIMを用いて動作を確認する．


\begin{enumerate}

\item 教科書，（以下教科書はコンピュータの構成と設計（パターソン＆ヘネシー）第四版を指すこととする）B.8節．「入力と出力」に示されている方法と，B.9節「システムコール」に示されている方法のそれぞれで，"Hello World"を表示せよ．両者の方式を比較し考察せよ．


\item アセンブリ言語中で使用する .data  .text および .align とは何か解説せよ．下記コード中の6行目の .data がない場合，どうなるかについて考察せよ．

{\baselineskip 3mm
\begin{verbatim}
 1:         .text
 2:         .align  2
 3: _print_message:
 4:         la      $a0, msg
 5:         li      $v0, 4
 6:         .data
 7:         .align  2
 8: msg:
 9:         .asciiz "Hello!!\n"
10:         .text
11:         syscall
12:         j       $ra
13: main:
14:         subu    $sp, $sp, 24
15:         sw      $ra, 16($sp)
16:         jal     _print_message
17:         lw      $ra, 16($sp)
18:         addu    $sp, $sp, 24
19:         j       $ra
\end{verbatim}
}

\item 教科書B.6節「手続き呼び出し規約」に従って，関数factを実装せよ．（以降の課題においては，この規約に全て従うこと）factをC言語で記述した場合は，以下のようになる．

{\baselineskip 3mm
\begin{verbatim}
 1: main()
 2: {
 3:   print_string("The factorial of 10 is ");
 4:   print_int(fact(10));
 5:   print_string("\n");
 6: }
 7: 
 8: int fact(int n)
 9: {
10:   if (n < 1)
11:     return 1;
12:   else
13:     return n * fact(n - 1);
14: }
\end{verbatim}
}

\item 素数を最初から100番目まで求めて表示するMIPSアセンブリ言語プログラムを作成してテストせよ．その際，素数を求めるために下記の2つのルーチンを作成すること．

\begin{center}
\begin{tabular}{lclcl}\hline
\centering
関数名&概要\\ \hline
test_primt(n)&nが素数なら1, そうでなければ0を返す\\ \hline
main()&整数を順々に素数判定し，100個プリント\\ \hline
\end{tabular}
\end{center}

C言語を用いた例．

{\baselineskip 3mm
\begin{verbatim}
 1: int test_prime(int n)
 2: {
 3:   int i;
 4:   for (i = 2; i < n; i++){
 5:     if (n % i == 0)
 6:       return 0;
 7:   }
 8:   return 1;
 9: }
10: 
11: int main()
12: {
13:   int match = 0, n = 2;
14:   while (match < 100){
15:     if (test_prime(n) == 1){
16:       print_int(n);
17:       print_string(" ");
18:       match++;
19:     }
20:     n++;
21:   }
22:   print_string("\n");
23: }
\end{verbatim}
}

実行例：

{\baselineskip 3mm
\begin{verbatim}
  2   3   5   7  11  13  17  19  23  29
 31  37  41  43  47  53  59  61  67  71
 73  79  83  89  97 101 103 107 109 113
127 131 137 139 149 151 157 163 167 173
179 181 191 193 197 199 211 223 227 229
233 239 241 251 257 263 269 271 277 281
283 293 307 311 313 317 331 337 347 349
353 359 367 373 379 383 389 397 401 409
419 421 431 433 439 443 449 457 461 463
467 479 487 491 499 503 509 521 523 541
\end{verbatim}
}


\item 素数を最初から100番目まで求めて表示するMIPSアセンブリ言語プログラムを作成してテストせよ．ただし，配列に実行結果を保存するようにmain部分を改造し，ユーザの入力によって任意の番目の配列要素を表示可能にせよ．

C言語を用いた例．

{\baselineskip 3mm
\begin{verbatim}
 1: int primes[100];
 2: int main()
 3: {
 4:   int match = 0, n = 2;
 5:   while (match < 100){
 6:     if (test_prime(n) == 1){
 7:       primes[match++] = n;
 8:     }
 9:     n++;
10:   }
11:   for (;;){
12:     print_string("> ");
13:     print_int(primes[read_int() - 1]);
14:     print_string("\n");
15:   }
16: }
\end{verbatim}
}


実行例：

{\baselineskip 3mm
\begin{verbatim}
> 15
47
> 100
541
\end{verbatim}
}




%
%	SECTION 2
%

\section{プログラムの作成方針}

今回はプログラムが比較的大きくなる課題3,4,5について，プログラムを作成していくための方針をここで示す．

\subsection{課題3}

課題3では，２つの部分に分けて関数を作成する．処理の概要は以下の通りに定め，下記でそれぞれについて解説する．

\begin{itemize}
\item[(1)]メインとなる処理を行うmain部
\item[(2)]再帰を用いて与えられた引数の階乗を計算するfact部
\end{itemize}

まず，(1)メインとなる処理を行うmain部では，プログラムのための出力と，fact関数に求めたい階乗の値を引数と与え，返ってきた数値をコンソールに表示する処理を行う

そして(2)のfact部では，再帰を用いて与えられた引数の階乗を計算し，それを値とし最終的な値として返す関数を作成する．

また，出力は以下のように定める．

{\baselineskip 3mm
\begin{verbatim}
The factorial of 10 is 3628800
\end{verbatim}
}


\subsection{課題4}

課題4では，以下の２つの関数を作成する．処理の概要は以下の通りに定め，下記でそれぞれについて解説する

\begin{itemize}
\item[(1)]与えられた引数が素数なら1，そうでなければ0を返す関数test_prime(n)
\item[(2)]整数を順々に素数判定し，先頭から100個をプリントする．
\end{itemize}


(1)test_prime(n)関数では，与えられた値に対してその数を素数かどうか判定し，引数が素数であれば1を，そうでなければ0を返す．
(2)main関数では，順に値をtest_prime(n)関数に与えていきた，100番目までの素数を数えて素数であるものだけを出力する．

\subsection{課題5}

課題5では，課題4で作成したプログラムのmain部分を改造し，素数を配列に実行しながらかつユーザの入力nに対してn番目の配列要素を出力するプログラムを作成する．

ユーザが実際に用いることを想定し，簡潔なエラー処理なども行う．


\end{verbatim}




%
%	SECTION 3
%

\section{プログラムリストおよび、その説明}

それぞれの課題について，完成したプログラムを末尾に添付する．このセクションでは，プログラムの主な構造について説明する．

\subsection{課題1}

\subsection{課題3}

\subsection{課題4}

\subsection{課題5}


\begin{verbatim}
　完成したプログラムを末尾に添付する．このセクションでは，プログラムの主な構造について説明する．
まず，8-20行ではstruct dataのデータ型の宣言部とそれを扱う関数の宣言部である．次に，subst,splitを26-53行付近で宣言している．substはstrの文字列中のc1をc2へと変換する．ここでは','を'\0'へと変換している．splitでは送られてきたstrの文字列中の区切りsepで分割し，substと同様に','へと'\0'変換し，分割したものをret[]に格納している．これらの文字列を示す複数からなる配列を返す．また"2013-06-06"のような日付を分けるために分割文字を'-'としてstruct_dateで同様の処理を行っている．
次に55-63,425-443,446-454行のget_line,perse_line,mainでは，標準入力され文章を1行ごと読み込み，解析し，データが%から始まっていればコマンド文字と引数をexec_commandに送る．そうでなければ一行をnew_profileに送る．
また142-180,102-115行のnew_profile,new_dateでは解析を行い，送られてきた一行を分割し，格納を行う．ここで，"2013/06/07"のように'-'で区切られず，間違った形式で入力された場合は処理されず，はじかれる．上記のsplitで分割した無事列配列を構造体の宣言部のデータ型に変換し，代入を行っている．文字列はstrncpy,数値はatoi関数を使用．これらをprofile_data_storeに格納している．profile_data_storeに格納できる件数は最大10000件となっている

\end{verbatim}

%
%	SECTION 4
%

\section{プログラムの使用例・テスト}

このセクションでは，プログラムの使用例を示しながら実際にテストを行う過程を示す．

\subsection{課題1}



\subsection{課題3}

プログラムを実行すると，10の階乗の値をコンソール上に以下のように出力する．

{\baselineskip 3mm
\begin{verbatim}
The factorial 10 is 3628800
\end{verbatim}
}



\subsection{課題4}



\subsection{課題5}



本プログラムは名簿データを管理するためのプログラムである．標準入力されたCSV形式のデータまたはファイル，％から始まるコマンドに応じた処理をし，処理結果を標準出力に表示する．入力形式については概要を参照．
まず、本プログラム(main.c)をgccによりコンパイルし，a.outという実行ファイルを作成する。test.csvというCSVファイルの読み込み（入力）を行う場合は、下のように./a.out < test.csvと入力する。

{\baselineskip 3mm
\begin{verbatim}
% gcc main.c
% ./a.out < test.csv
\end{verbatim}
}

test.csvは以下のようであった場合を想定する。

{\baselineskip 3mm
\begin{verbatim}

1,Takahashi Kazuyuki,1977-04-27,Saitama,Fukuoka Softbank Howks
2,Yuta Totsuka,1993-04-24,Okayama,Kurashiki
3,Kubo Shota,1993-04-16,Ehime,Matuyamakita
4,Oigawa Satoshi,1993-04-18,Shimane,Matueminami
%P 0
%P 2
%P -2
%P 5
%C
\end{verbatim}
}

このとき以下のように、ユーザがより読み取りやすいように出力を得ることができる．

{\baselineskip 3mm
\begin{verbatim}

(line1)Id    : 1
Name  : Takahashi Kazuyuki
Birth : 1977-04-27
Addr  : Saitama
Com.  : Fukuoka Softbank Howks

(line2)Id    : 2
Name  : Yuta Totsuka
Birth : 1993-04-24
Addr  : Okayama
Com.  : Kurashiki

(line3)Id    : 3
Name  : Kubo Shota
Birth : 1993-04-16
Addr  : Ehime
Com.  : Matuyamakita

(line4)Id    : 4
Name  : Oigawa Satoshi
Birth : 1993-04-18
Addr  : Shimane
Com.  : Matueminami

(line1)Id    : 1
Name  : Takahashi Kazuyuki
Birth : 1977-04-27
Addr  : Saitama
Com.  : Fukuoka Softbank Howks

(line2)Id    : 2
Name  : Yuta Totsuka
Birth : 1993-04-24
Addr  : Okayama
Com.  : Kurashiki

(line3)Id    : 3
Name  : Kubo Shota
Birth : 1993-04-16
Addr  : Ehime
Com.  : Matuyamakita

(line4)Id    : 4
Name  : Oigawa Satoshi
Birth : 1993-04-18
Addr  : Shimane
Com.  : Matueminami

登録件数を確認してください．

登録件数：4件

\end{verbatim}
}

入力中の”％P 2”, "％P 0", "％P -2"はそれぞれ"前から2件表示"，"全件表示"，"後ろから2件表示"する処理を呼び出すコマンドである．
％Cは登録件数の表示をする処理を呼び出すコマンドである．

次に、以下の新しいデータを入力し、以下のコマンドを入力したとする。

{\baselineskip 3mm
\begin{verbatim}

5,Mori Masataka,1993-03-24,Okayama,Amaki
%W test.csv

\end{verbatim}
}

％Wは指定ファイルに書き込みを行うコマンドである。書き込みを行われたtest.csvファイルは以下のようになる。

{\baselineskip 3mm
\begin{verbatim}
hashi Kazuyuki,1977-04-27,Saitama,Fukuoka Softbank Howks
3,Yamamoto Yasutaka,1993-07-12,Okayama,Kurasikiminami
1,Kubo Shota,1993-04-16,Ehime,Matuyamakita
4,Oigawa Satoshi,1993-04-18,Shimane,Matueminami
5,Mori Masataka,1993-03-24,Okayama,Amaki
\end{verbatim}
}

次に検索を行ってみる。

{\baselineskip 3mm
\begin{verbatim}

%F Saitama
%F 1993-07-12
%F 4

\end{verbatim}
}

％Fの後ろに入力されたwordと一致するものを％Pと同様の形式で出力する。出力結果は以下のようになる。

{\baselineskip 3mm
\begin{verbatim}


%F Saitama
(line1)
id:2
name:Takahashi Kazuyuki
Birth:1977-04-27
addr:Saitama
comment:Fukuoka Softbank Howks

%F 1993-07-12
(line2)
id:3
name:Yamamoto Yasutaka
Birth:1993-07-12
addr:Okayama
comment:Kurasikiminami

%F 4 (line4)
id:4
name:Oigawa Satoshi
Birth:1993-04-18
addr:Shimane
comment:Matueminami


\end{verbatim}
}

％Sはソートコマンドである。％Sの後にそれぞれ対応するカラムの番号を入力することで、並び替えが行われる。（1:id, 2:name, 3:birth, 4:addr, 5:comment）以下に、1でソートした例を示す。


{\baselineskip 3mm
\begin{verbatim}



\hashi Kazuyuki,1977-04-27,Saitama,Fukuoka Softbank Howks
3,Yamamoto Yasutaka,1993-07-12,Okayama,kojima
1,Kubo Shota,1993-04-16,Ehime,Matuyamakita
4,Oigawa Satoshi,1993-04-18,Shimane,Matueminami
5,Mori Masataka,1993-03-24,Okayama,Amaki
ソート後)
1,Kubo Shota,1993-04-16,Ehime,Matuyamakita
2,Takahashi Kazuyuki,1977-04-27,Saitama,Fukuoka Softbank Howks
3,Yamamoto Yasutaka,1993-07-12,Okayama,kojima
4,Oigawa Satoshi,1993-04-18,Shimane,Matueminami
5,Mori Masataka,1993-03-24,Okayama,Amaki

\end{verbatim}
}

また、％Sでは実際にソートされた結果は表示されない。ソートしたものを％Wを使い、csvファイルに書き込んだものを上記には示している。
％Eは以下のような実行が行われる

{\baselineskip 3mm
\begin{verbatim}

%E
id を入力してください.
 id:1
 Before
 1,Kubo Shota,1993-04-16,Ehime,Matuyamakita
 After

\end{verbatim}
}

上記はid:1のデータの編集を行う場合である。Afterの後に

{\baselineskip 3mm
\begin{verbatim}

1,Ishii Isamu, 1993-08-09,Okayama,Konan

\end{verbatim}
}

と入力した場合、以下のように編集される。また、以前行ったソート後の状態であるとする。

{\baselineskip 3mm
\begin{verbatim}

shii Isamu,1993-08-09,Okayama,Konan
2,Takahashi Kazuyuki,1977-04-27,Saitama,Fukuoka Softbank Howks
3,Yamamoto Yasutaka,1993-07-12,Okayama,kojima
4,Oigawa Satoshi,1993-04-18,Shimane,Matueminami
5,Mori Masataka,1993-03-24,Okayama,Amaki

\end{verbatim}
}

また、％Hはヘルプ画面である。実行結果は以下の通りで、本プログラムにおけるコマンド一覧を確認することが出来るようになっている。

{\baselineskip 3mm
\begin{verbatim}

%H

# HELP
## Commands
- Q: Quit
- C: check the number of registered datas
- P n: Print n elements (n=0:all, n<0:from behind)
- R file: Read from file
- W file: Write as file
- F word: Search by word, print like P
- S n: Sort datas as the column of n
- H: Show usage of commands

\end{verbatim}
}

以上がコマンドの使用例である。


%
%	SECTION 5
%

\section{プログラム作成における考察}

\begin{verbatim}
プログラムの作成過程での考察は，分割して返された文字列を代入する際に，strncpyを使うようにした．数値の代入をするためにはatoi関数を使い値を直接代入するようにした．またcmd_print関数内では初め，すべてのnの場合分けを行いループを考え，その中のすべてで表示させていたが，記述量も多くなり，効率的では無いと考えたために，printで表示させる部分だけを別関数で作成し，ループ内に返されるように変更した．

cmd_find 関数では入力された引 数が文字列であるため,strcmp で比較を行うようにした.これはそれぞれの型の変換を行うこと なく比較ができるためにこの様な比較方法を採用した.ソートにおいても別関数で合分けを行い, どのような大小関係(数字,アルファベット順)においても正,0,負のなどの統一の値が返せる ようにした.そうすることにより,並び代えの処理も同じになり,記述量を減らせるようにした. またバブルソートを採用しているのは,なるべく簡単な記述を採用し,分かりやすいプログラムを 作成しようと考えたためである.

また、ユーザビリティを考慮した工夫をいくつか行った。１つ目に、都度プログラムが行っていることとユーザに期待していることを表示するようにした。例を挙げると、プログラム開始時には”Program has started. Type a command after a symbol of percent. To show help, type H command."と出力するようにし、また各コマンドにもこのようなユーザガイドを付けた。

２つ目に、プログラムがユーザの入力を受け付けているのかどうか分かりにくい場面があると感じたため、入力待ち時にはコロンを出力するようにして、ユーザは、プログラム開始時やあるコマンドの終了時などに入力をしていいのかどうか分かりやすくなるよう工夫をした.

\end{verbatim}

%
%	SECTION 6
%

\section{得られた結果に関する，あるいは試問に対する回答}

\begin{verbatim}

struct profile *newprofileのように構造体の宣言にポインタがついているものがある．これはポインタを付けることによって，格納し，蓄積させたデータのすべてを返すのではなく先頭アドレスだけを返している．構造体内のすべての数値，文字列を返すよりも，効率が上がると考えたためである．また今回のプログラムではn件の登録件数に対し，その件数を上回る件数の表示を行おうとすると，登録件数を確認するように促し，表示がされないようにしている．この場合に表示を行った場合に，多少分かりにくくなってしまうのでは無いかと考え，まず登録件数を確認するように促すようにした．また最大の登録件数を越えて，新たなデータを登録しようとしたさいに，perse_line内で条件文により，最大登録件数になってしまっていることを伝え，そこで処理を終えるようになっている．

コマンド％E
新たなコマンドとして%E, 編集を作成した.プログラムの使用例でも記述したように,編集したい id のデータを再び入力し,上書きするコマンドである.入力した id を atoi 関数で数値変換し, 既に登録されている id を数値として比較し,同じ id が見つかれば既に登録されているデータを CSV 形式で表示させる.表示例はプログラム使用例に示したとおりである. その後,変更したいデータの入力を行う.この時に’\0’ のみや間違った形式で入力すると弾かれ るようになっている.新たに入力したデータの分割には new_profile を使用しているが,分割が 正常に終了すれば profile_data_nitem++を行うようになっている.そのため編集の際は成功し た後に,profile_data_nitems--を行うようにし,データの総数は増えないようにしている.

コマンド％H
また、新たなコマンドとして％Hも追加した。コマンドの確認を仕様書を見直して確認する必要がないよう、全てのコマンドを、プログラム内で参照できるように実装した。

\end{verbatim}

\newpage

%
%	SECTION 6
%

\section{作成したプログラムのソースコード}

\subsection{課題1}

\lstinputlisting[caption=putc.s, label=putc.s]{./source/putc.s}

\lstinputlisting[caption=putc2.s, label=putc2.s]{./source/putc2.s}

\subsection{課題3}

\lstinputlisting[caption=factorial.s, label=factorial.s]{./source/factorial.s}

\subsection{課題4}

\lstinputlisting[caption=prime.s, label=prime.s]{./source/prime.s}

\subsection{課題5}

\lstinputlisting[caption=prime2.s, label=prime2.s]{./source/prime2.s}


\end{document}

